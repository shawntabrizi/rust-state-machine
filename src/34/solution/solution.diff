diff --git a/src/proof_of_existence.rs b/src/proof_of_existence.rs
index 979fd25..b6fb63c 100644
--- a/src/proof_of_existence.rs
+++ b/src/proof_of_existence.rs
@@ -56,27 +56,32 @@ impl<T: Config> Pallet<T> {
 // We should expect that the caller of each call will be provided by the dispatcher,
 // and not included as a parameter of the call.
 pub enum Call<T: Config> {
-	/*
-		TODO:
-		Create variants for:
-		- `CreateClaim`
-		- `RevokeClaim`
-
-		Remember that you only need to pass in the `claim` data, as `caller` information is passed
-		in through the `dispatch` logic.
-	*/
-	RemoveMe(core::marker::PhantomData<T>),
+	CreateClaim { claim: T::Content },
+	RevokeClaim { claim: T::Content },
 }
 
 /// Implementation of the dispatch logic, mapping from `Call` to the appropriate underlying
 /// function we want to execute.
-/*
-	TODO:
-	Implement `crate::support::Dispatch` for `Pallet<T>`.
+impl<T: Config> crate::support::Dispatch for Pallet<T> {
+	type Caller = T::AccountId;
+	type Call = Call<T>;
 
-	In your `dispatch` logic, match on `call` and forward the `caller` and `claim` data to the
-	appropriate function.
-*/
+	fn dispatch(
+		&mut self,
+		caller: Self::Caller,
+		call: Self::Call,
+	) -> crate::support::DispatchResult {
+		match call {
+			Call::CreateClaim { claim } => {
+				self.create_claim(caller, claim)?;
+			},
+			Call::RevokeClaim { claim } => {
+				self.revoke_claim(caller, claim)?;
+			},
+		}
+		Ok(())
+	}
+}
 
 #[cfg(test)]
 mod test {
