diff --git a/src/balances.rs b/src/balances.rs
index 42d66d0..68b2bb3 100644
--- a/src/balances.rs
+++ b/src/balances.rs
@@ -36,7 +36,7 @@ impl<T: Config> Pallet<T> {
 	}
 }
 
-/* TODO: Add the `#[macros::call]` attribute right here. */
+#[macros::call]
 impl<T: Config> Pallet<T> {
 	/// Transfer `amount` from one account to another.
 	/// This function verifies that `from` has at least `amount` balance to transfer,
@@ -60,35 +60,6 @@ impl<T: Config> Pallet<T> {
 	}
 }
 
-// A public enum which describes the calls we want to expose to the dispatcher.
-// We should expect that the caller of each call will be provided by the dispatcher,
-// and not included as a parameter of the call.
-/* TODO: Remove `enum Call`, this is being generated automatically by `#[macros::call]`. */
-pub enum Call<T: Config> {
-	Transfer { to: T::AccountId, amount: T::Balance },
-}
-
-/// Implementation of the dispatch logic, mapping from `BalancesCall` to the appropriate underlying
-/// function we want to execute.
-/* TODO: Remove this `Dispatch` impl, this is also being generated by `#[macros::call]`. */
-impl<T: Config> crate::support::Dispatch for Pallet<T> {
-	type Caller = T::AccountId;
-	type Call = Call<T>;
-
-	fn dispatch(
-		&mut self,
-		caller: Self::Caller,
-		call: Self::Call,
-	) -> crate::support::DispatchResult {
-		match call {
-			Call::Transfer { to, amount } => {
-				self.transfer(caller, to, amount)?;
-			},
-		}
-		Ok(())
-	}
-}
-
 #[cfg(test)]
 mod tests {
 	struct TestConfig;
diff --git a/src/main.rs b/src/main.rs
index 474d821..a1702e7 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -125,15 +125,14 @@ fn main() {
 		extrinsics: vec![
 			support::Extrinsic {
 				caller: alice.clone(),
-				/* TODO: Update the enum name to match what is generated with the macro. */
-				call: RuntimeCall::Balances(balances::Call::Transfer {
+				call: RuntimeCall::Balances(balances::Call::transfer {
 					to: bob.clone(),
 					amount: 30,
 				}),
 			},
 			support::Extrinsic {
 				caller: alice.clone(),
-				call: RuntimeCall::Balances(balances::Call::Transfer { to: charlie, amount: 20 }),
+				call: RuntimeCall::Balances(balances::Call::transfer { to: charlie, amount: 20 }),
 			},
 		],
 	};
