diff --git a/src/main.rs b/src/main.rs
index 175378a1..5db0a593 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -19,18 +19,12 @@ mod types {
 	pub type Content = &'static str;
 }
 
-// These are all the calls which are exposed to the world.
-// Note that it is just an accumulation of the calls exposed by each module.
-/* TODO: Remove the `RuntimeCall`. This is now generated by the `#[macros::runtime]`. */
-pub enum RuntimeCall {
-	Balances(balances::Call<Runtime>),
-	ProofOfExistence(proof_of_existence::Call<Runtime>),
-}
-
 // This is our main Runtime.
-// It accumulates all of the different pallets we want to use.
-/* TODO: Add the `#[macros::runtime]` attribute here and remove duplicate code listed by TODOs. */
+// It accumulates all of the different pallets we want to use,
+// functions implemented on the Runtime allow us to access those pallets and execute blocks of
+// transactions.
 #[derive(Debug)]
+#[macros::runtime]
 pub struct Runtime {
 	system: system::Pallet<Self>,
 	balances: balances::Pallet<Self>,
@@ -51,67 +45,7 @@ impl proof_of_existence::Config for Runtime {
 	type Content = types::Content;
 }
 
-/* TODO: Remove all this. It is now generated by the `#[macros::runtime]` attribute. */
-impl Runtime {
-	// Create a new instance of the main Runtime, by creating a new instance of each pallet.
-	fn new() -> Self {
-		Self {
-			system: system::Pallet::new(),
-			balances: balances::Pallet::new(),
-			proof_of_existence: proof_of_existence::Pallet::new(),
-		}
-	}
-
-	// Execute a block of extrinsics. Increments the block number.
-	fn execute_block(&mut self, block: types::Block) -> support::DispatchResult {
-		self.system.inc_block_number();
-		if block.header.block_number != self.system.block_number() {
-			return Err("block number does not match what is expected");
-		}
-		// An extrinsic error is not enough to trigger the block to be invalid. We capture the
-		// result, and emit an error message if one is emitted.
-		for (i, support::Extrinsic { caller, call }) in block.extrinsics.into_iter().enumerate() {
-			self.system.inc_nonce(&caller);
-			let _res = self.dispatch(caller, call).map_err(|e| {
-				eprintln!(
-					"Extrinsic Error\n\tBlock Number: {}\n\tExtrinsic Number: {}\n\tError: {}",
-					block.header.block_number, i, e
-				)
-			});
-		}
-		Ok(())
-	}
-}
-
-/* TODO: Remove all this too. Dispatch logic is auto-generated. */
-impl crate::support::Dispatch for Runtime {
-	type Caller = <Runtime as system::Config>::AccountId;
-	type Call = RuntimeCall;
-	// Dispatch a call on behalf of a caller. Increments the caller's nonce.
-	//
-	// Dispatch allows us to identify which underlying module call we want to execute.
-	// Note that we extract the `caller` from the extrinsic, and use that information
-	// to determine who we are executing the call on behalf of.
-	fn dispatch(
-		&mut self,
-		caller: Self::Caller,
-		runtime_call: Self::Call,
-	) -> support::DispatchResult {
-		// This match statement will allow us to correctly route `RuntimeCall`s
-		// to the appropriate pallet level function.
-		match runtime_call {
-			RuntimeCall::Balances(call) => {
-				self.balances.dispatch(caller, call)?;
-			},
-			RuntimeCall::ProofOfExistence(call) => {
-				self.proof_of_existence.dispatch(caller, call)?;
-			},
-		}
-		Ok(())
-	}
-}
-
-/* TODO: Update the extrinsics to match the automatically generated `RuntimeCall`. */
+// The main entry point for our simple state machine.
 fn main() {
 	// Create a new instance of the Runtime.
 	// It will instantiate with it all the modules it uses.
@@ -130,14 +64,14 @@ fn main() {
 		extrinsics: vec![
 			support::Extrinsic {
 				caller: alice.clone(),
-				call: RuntimeCall::Balances(balances::Call::transfer {
+				call: RuntimeCall::balances(balances::Call::transfer {
 					to: bob.clone(),
 					amount: 30,
 				}),
 			},
 			support::Extrinsic {
 				caller: alice.clone(),
-				call: RuntimeCall::Balances(balances::Call::transfer { to: charlie, amount: 20 }),
+				call: RuntimeCall::balances(balances::Call::transfer { to: charlie, amount: 20 }),
 			},
 		],
 	};
@@ -147,13 +81,13 @@ fn main() {
 		extrinsics: vec![
 			support::Extrinsic {
 				caller: alice.clone(),
-				call: RuntimeCall::ProofOfExistence(proof_of_existence::Call::create_claim {
+				call: RuntimeCall::proof_of_existence(proof_of_existence::Call::create_claim {
 					claim: "Hello, world!",
 				}),
 			},
 			support::Extrinsic {
 				caller: bob.clone(),
-				call: RuntimeCall::ProofOfExistence(proof_of_existence::Call::create_claim {
+				call: RuntimeCall::proof_of_existence(proof_of_existence::Call::create_claim {
 					claim: "Hello, world!",
 				}),
 			},
@@ -165,13 +99,13 @@ fn main() {
 		extrinsics: vec![
 			support::Extrinsic {
 				caller: alice,
-				call: RuntimeCall::ProofOfExistence(proof_of_existence::Call::revoke_claim {
+				call: RuntimeCall::proof_of_existence(proof_of_existence::Call::revoke_claim {
 					claim: "Hello, world!",
 				}),
 			},
 			support::Extrinsic {
 				caller: bob,
-				call: RuntimeCall::ProofOfExistence(proof_of_existence::Call::create_claim {
+				call: RuntimeCall::proof_of_existence(proof_of_existence::Call::create_claim {
 					claim: "Hello, world!",
 				}),
 			},
